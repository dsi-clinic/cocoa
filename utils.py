""""
Utility Functions for running automated code and repo reviews.
"""

import os
import json
import argparse
import git
import pyflakes.api
from pylint.lint import Run
from pylint.reporters.text import TextReporter
from io import StringIO

def count_functions(cell):
    """Count the number of functions defined in a Jupyter Notebook cell."""
    code = cell['source']
    return len([1 for line in code if line.strip().startswith('def ')])

def process_notebook(file_path):
    """Process a Jupyter Notebook and count the cells, lines of code and functions."""
    with open(file_path, 'r', encoding='utf-8') as f_handle:
        notebook = json.load(f_handle)
        cells = notebook['cells']
        num_cells = len(cells)
        num_lines = 0
        num_functions = 0
        max_lines_in_cell = 0
        for cell in cells:
            if cell['cell_type'] == 'code':
                lines_in_cell = len([1 for line in cell['source'] if line.strip()])
                num_lines += lines_in_cell
                max_lines_in_cell = max(max_lines_in_cell, lines_in_cell)
                num_functions += count_functions(cell)
        return num_cells, num_lines, num_functions, max_lines_in_cell

def walk_and_process(dir_path, no_filter_flag, lint_flag):
    """Walk through directory and process all Jupyter Notebooks."""
    notebook_count = 0
    stats_printed = 0
    python_file_count = 0
    pylint_warnings = []

    for root, dirs, files in os.walk(dir_path):
        for file in files:
            file_path = os.path.join(root, file)

            if file.endswith('.ipynb'):
                notebook_count += 1
                num_cells, num_lines, num_functions, max_lines_in_cell = process_notebook(file_path)
                if no_filter_flag or \
                        (num_cells > 10 or max_lines_in_cell > 15 or num_functions >0):
                    stats_printed += 1
                    print(f'File: {file_path}')
                    print(f'\tNumber of cells: {num_cells}')
                    print(f'\tLines of code: {num_lines}')
                    print(f'\tNumber of function definitions: {num_functions}')
                    print(f'\tMax lines in a cell: {max_lines_in_cell}')
                    print('-' * 40)
            elif file.endswith('.py'):
                python_file_count += 1
                number_of_messages = run_pyflakes_file(file_path)
                if lint_flag:
                    pylint_warnings = get_pylint_warnings(file_path)
                    if len(pylint_warnings) > 0:
                        for warning in pylint_warnings:
                            print(f"{warning}")
                if number_of_messages > 0 or len(pylint_warnings) > 0:
                    stats_printed += 1

    print(f"Files information printed: {stats_printed}")

def run_pyflakes_file(file_path):
    """Run a python file through pyflakes. returns the number of warnings raised."""

    with open(file_path, "r", encoding="utf-8") as file:
        file_content = file.read()
        number_of_warnings = pyflakes.api.check(file_content, file_path)

    return number_of_warnings

def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description='Process Cod Repository.')
    parser.add_argument('dir_path', type=str, help='Directory path to start the search from')
    return parser.parse_args()

def is_git_repo(repo_path):
    """
    Return a boolean if the directory supplied is a git repo.
    """
    return git.Repo(repo_path).git_dir is not None

def get_remote_branches_info(repo_path):
    """This function reutrns the branch information from the remote repository."""
    repo = git.Repo(repo_path)
    remote_branches = repo.remote().refs

    branch_info = []
    for branch in remote_branches:
        if branch.remote_head == "HEAD":
            continue

        commits_diff = repo.git.rev_list('--left-right', '--count', f'origin/main...{branch.name}')
        num_ahead, num_behind = commits_diff.split('\t')
        branch_info.append( [branch.name, num_ahead, num_behind])

    for branch, behind, ahead in branch_info:
        print(f"Branch: {branch}")
        print(f"Commits behind main: {behind}")
        print(f"Commits ahead of main: {ahead}")
        print()

    return branch_info

def get_pylint_warnings(filepath):
    """ This function (generated by chatgpt) runs pylint on files and returns all warnings"""
    pylint_output = StringIO()
    reporter = TextReporter(pylint_output)
    Run([filepath], reporter=reporter, do_exit=False)
    pylint_output.seek(0)
    output_lines = pylint_output.readlines()
    #warnings = [line for line in output_lines if 'warning' in line.lower()]
    warnings = [line.replace('\n', '') for line in output_lines]
    return warnings
